# Try/Except
# In Python, error handling can be done using a try/except block.
# Implement except blocks to handle the exceptions that will be raised for the following try blocks:

print('\n--------------------------------------------------------------')
print('Try / Except')
print('--------------------------------------------------------------')

# Example 1
try:
    string = 'hello'
    string[0] = 'm'
    print(string)
except Exception as err:
    print("Error:", err)
finally:
    print('I happen regardless of any exceptions.')

# Example 2
try:
    print(x)
except Exception as err:
    print("Error:", err)
finally:
    print('I happen regardless of any exceptions.')

# Print List
# Given a list of elements, write a function, print_list that prints each element of the list out.

print('\n--------------------------------------------------------------')
print('Print List')
print('--------------------------------------------------------------')

def print_list(list):
    toPrint = str(list[0])
    for i in range(1, len(list)):
        toPrint += ' ' + str(list[i])
    print(toPrint)

lst1 = [1, 2, 5, 1429]
lst2 = ['this', 'list', 'is', 'being', 'printed']
lst3 = ['there', 'are', 2, 'data', 'types', 'being', 'printed']
lst4 = [[1, 2], ['hello', 'from', 'within']]
print_list(lst1)        # 1 2 5 1429
print_list(lst2)        # this list is being printed
print_list(lst3)        # there are 2 data types being printed
print_list(lst4)        # [1, 2] ['hello', 'from', 'within']

# Check Membership
# You are a bouncer at a club and you have a list of approved guests.
# Write a function check_membership that accepts the approved guests list guest_list and a name guest_name as arguments,
# and checks if the guest_name is on the list.

print('\n--------------------------------------------------------------')
print('Guest List')
print('--------------------------------------------------------------')

def check_membership(guest_name, guest_list):
    return guest_name in guest_list

guest_list = ["George", "Anthony", "Susan", "Tiffany"]
print(check_membership("Sally", guest_list))        # False
print(check_membership("Anthony", guest_list))      # True

# Double That Penny
# It's time to practice writing a while loop in Python. As you've seen, the syntax is similar to JavaScript, except using : at the end
# of the loop definition and indentation for the block of code to run with that loop.
# Write a while loop to calculate the total number of pennies resulting from each doubling. End the loop when the value is over a million dollars.

print('\n--------------------------------------------------------------')
print('Double That Penny')
print('--------------------------------------------------------------')

print("** Doubling Penny **")

# How many times would a penny need to double to generate a million dollars?
count = 0
total = 0

# STEP 2: Write the while loop
while total < 1000000:
    count += 1
    if total == 0:
        total = 0.01
    else:
        total *= 2

print('Double', count, 'times')

# How much money has been generated at that point?
print('${:,}'.format(total))

# Valid Hex Code
# Create a function that determines whether a string is a valid hex code.
# A hex code must begin with a pound key # and is exactly 6 characters in length.
# Each character must be a digit from 0-9 or an alphabetic character from A-F.
# All alphabetic characters may be uppercase or lowercase.

print('\n--------------------------------------------------------------')
print('Valid Hex Code')
print('--------------------------------------------------------------')

def is_valid_hex_code(string):
    charCheck = True
    for char in string.upper():
        if char not in '#0123456789ABCDEF':
            charCheck = False

    return ((len(string) == 7)
             and string.startswith('#')
             and charCheck)

print(is_valid_hex_code("#CD5C5C")) #> True
print(is_valid_hex_code("#EAECEE")) #> True
print(is_valid_hex_code("#eaecee")) #> True

print(is_valid_hex_code("#CD5C58C"))
# Prints False
# Length exceeds 6

print(is_valid_hex_code("#CD5C5Z"))
# Prints False
# Not all alphabetic characters in A-F

print(is_valid_hex_code("#CD5C&C"))
# Prints false
# Contains unacceptable character

print(is_valid_hex_code("CD5C5C"))
# Prints False
# Missing #

# Sequence of Numbers
# The sequence of numbers is generated by describing each group of identical digits in the previous term.
# Given a string of numbers, translate the string into a sequence of numbers that describes the count of identical digits.
# For example, the string "1" has "one 1" and would be translated to 11.
# The string "11" is interpreted as "two 1s" which is translated to 21.
# The string "1211" is interpreted as "one 1, one 2, two 1s" which is translated to 111221.
# This is a tough one. Try not to look at the solution unless you spend more than 30 minutes on it.

print('\n--------------------------------------------------------------')
print('Sequence of Numbers')
print('--------------------------------------------------------------')

# Write your function, here.
# There are hints after the print statements
def seq_of_numbers(seq):
    returnString = ''
    count = 1

    for i in range(len(seq)-1):
        if seq[i] == seq[i+1]:
            count += 1
        else:
            returnString += f'{count}{seq[i]}'
            count = 1
    # additional term addition to the end of the return string to account for the last check,
    # otherwise the loop would end with the count being incremented but not added to the return string
    returnString += f'{count}{seq[i]}'
    return returnString

# AS AN ALTERNATIVE - to account for the last check, could concatenate a space onto the seq variable
# so that there is an additional character and the additional returnString command would not be necessary
# This is outlined in the pseudo code down below, but I didn't reference it before coming up with the
# current solution.

print(seq_of_numbers("1211"))
# This is "one 1, one 2, two 1s"
# Prints "111221"

print(seq_of_numbers("111221"))
# This is "three 1s, two 2s, and one 1"
# Prints "312211"

print(seq_of_numbers("31131211131221"))
# This is "one 3, two 1s, one 3, one 1, one 2, three 1s,
#    one 3, one 1, two 2s, and one 1"
# Prints "13211311123113112211"

###########################################################
# AN ALGORITHM
# An algorithm for performing this without a data structure
# means you have to think about what you're trying to look
# for.
#
# If you scan the string two characters at a time, when they
# change, you know that you have started a new sequence of
# numbers. You can add the current number of characters that
# you've scanned to a result.
#
# For example, say you had "111221". You would start the
# count at 1 and compare the characters at indices 0 and 1.
# Since they are the same, you would increment the current
# count to two, because you will have found two 1s. Then,
# you would compare the characters at indices 1 and 2.
# Again, they are both 1s, so you would increment the count
# to 3. The next comparison, the one at indices 2 and 3
# yields the characters "1" and "2". At this point, the
# characters have changed. The current count is 3, and the
# current character is "1", so you would concatenate those
# onto a result "31". Then, you would set the current count
# back to 1 (because you have found one 2), and continue
# with the same process.


############################################################
# PSEUDOCODE
#
# Concatenate an empty space to the end of the value passed
#    into the function. This will let you compare the entire
#    length of the original string with a guarantee that the
#    two last characters do not match.
# Create an empty string to which you will append the
#    counts and digits
# Initialize an index to 0 for looping over the string
# Initialize a counter variable to record the count of the
#    current character
# Using the index variable, loop from 0 to the length of the
#    string minus 1 (because you don't want to examine the
#    last character, the space that you added)
#   If the current character is not equal to the next
#      character, then concatenate the current count and the
#      current character to the result string and set the
#      current count back to 1
#   Otherwise, just increment the current character count by
#      1
#   Increment the index by 1
# Return the result

# Split On Capitals
# Create a function which adds spaces before every capital in a word. Lower case the whole string afterwards.

print('\n--------------------------------------------------------------')
print('Split On Capitals')
print('--------------------------------------------------------------')

# Write your function, here.
def cap_space(string):
    retString = ''
    for char in string:
        if char.isupper():
            char = f' {char.lower()}'
        retString += char
    return retString

print(cap_space("helloWorld"))     #> "hello world"
print(cap_space("iLoveMyTeapot"))  #> "i love my teapot"
print(cap_space("stayIndoors"))    #> "stay indoors"

# Count Characters In String
# Create a function that takes two strings as arguments and returns the number of times the first string (the single character) is found in the second string.

print('\n--------------------------------------------------------------')
print('Count Characters In String')
print('--------------------------------------------------------------')

# Write your function, here.
def char_count(letter, string):
    count = 0
    for char in string:
        if char == letter:
            count += 1
    return count

print(char_count("a", "App Academy"))         #> 1
print(char_count("c", "Chamber of Secrets"))  #> 1
print(char_count("b", "big fat bubble"))      #> 4

# Vowel Count
# Create a function called vowel_count that takes in a string and returns a count of how many vowels are in the string.

print('\n--------------------------------------------------------------')
print('Vowel Count')
print('--------------------------------------------------------------')

# Write your solution here.
def vowel_count(string):
    vowels = 'aeiou'
    count = 0

    for char in string.lower():
        if char in vowels:
            count += 1
    return count

print(vowel_count("App Academy"))         #> 4
print(vowel_count("Coding Expert"))       #> 4
print(vowel_count("Supreme"))             #> 3
print(vowel_count("Chamber of Secrets"))  #> 5

# Add Upper
# Create a function add_upper that takes a string and returns all of the uppercase characters in the string.

print('\n--------------------------------------------------------------')
print('Add Upper')
print('--------------------------------------------------------------')

# Write your solution here.
def add_upper(string):
    upperString = ''
    for char in string:
        if char.isupper():
            upperString += char
    return upperString

print(add_upper("ApPlE"))        #> APE
print(add_upper("Coding"))       #> C
print(add_upper("PIano"))        #> PI
print(add_upper("SUPREME"))      #> SUPREME

# Regex - Challenge
# RegEx is a powerful tool that can be used to pattern match and validate values. In Python, the built in re module is used to work with regular expressions. See the docs here for a quick intro into how to use the module.

# Write a function, valid_zip_code that accepts a string and checks to see if it's a valid U.S. zip code. A valid U.S. zip code follows the following rules:

#     Mandatory 5 digits
#         Ranging from 0-9
#     Optional 4 digits for area granularity
#         Ranging from 0-9
#     Mandatory 5 and optional 4 separated by a hyphen
#         Hyphen not present if optional 4 isn't present If the zip code matches, return the zip code. If not, return an error text message.


print('\n--------------------------------------------------------------')
print('Regex - Challenge')
print('--------------------------------------------------------------')
# Write your solution here.
import re

def valid_zip_code(zip):
    fiveDigitPattern = re.compile(r'\d{5}')
    nineDigitPattern = re.compile(r'\d{5}-\d{4}')
    if fiveDigitPattern.fullmatch(zip) or nineDigitPattern.fullmatch(zip):
        return zip
    return 'The zip code you entered is invalid'

# solution provided in exercise:
# import re
# def valid_zip_code(zip):
#     pattern = "^\d{5}(?:[-\s]\d{4})?$"
#     is_valid = re.search(pattern, zip)
#     if is_valid:
#         return zip
#     else:
#         return "The zip code you entered is invalid"

zip1 = '47243'
zip2 = '23128-'
zip3 = '01237-1238'
zip4 = '91374-31'
zip5 = '1321-9883'
zip6 = '6320'

print(valid_zip_code(zip1))     # '47243'
print(valid_zip_code(zip2))     # "The zip code you entered is invalid"
print(valid_zip_code(zip3))     # '01237-1238'
print(valid_zip_code(zip4))     # "The zip code you entered is invalid"
print(valid_zip_code(zip5))     # "The zip code you entered is invalid"
print(valid_zip_code(zip6))     # "The zip code you entered is invalid"
